\subsection{Программа для расчёта течения в каверне по схеме SIMPLE}
\label{sec:prog_cavity_fdm}

\subsubsection{Постановка задачи}

Для иллюстрации работы алгоритма SIMPLE с аппроксимацией методом конечных разностей, представленного в \secref{sec:simple_scheme_fdm}, рассмотрим задачу о 
течении в каверне. Постановку задачи представлена на \figref{fig:cavity}.

\begin{figure}[h]
\centering
\includegraphics[width=0.4\linewidth]{cavity2d.png}
\caption{Область расчёта задачи о каверне}
\label{fig:cavity}
\end{figure}

Задача реализована в тесте \ename{[cavity-fdm-simple]} в файле \ename{cavity_fdm_test.cpp}.

Программа проводит итерации стартуя от начального нулевого состояния
$u=v=p=0$ до тех пор, пока невязка не достигнет заданного порога.
На каждой итерации поле давления и векторное поле скорости сохраняются
на основной сетке в файл \ename{cavity2.vtk.series}.

Итоговый результат (для $\eps=10^{-2}$) представлен на \figref{fig:cavity-result}.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{cavity2d-result.png}
\caption{Область расчёта задачи о каверне}
\label{fig:cavity-result}
\end{figure}

Для отображения вектора поля скорости в Paraview см. справку в \ref{sec:paraview-glyph}.

Для работы с разнесённой сеткой в классе \cvar{cfd::RegularGrid2D}
представлены функции
\begin{itemize}
\item \cvar{cfd::RegularGrid2D::cell_centered_grid()}  -- построить сетку по центрам ячеек (``чёрную'' сетку для $p$),
\item \cvar{cfd::RegularGrid2D::xface_centered_grid()} -- построить сетку по центрам $x$-граней (``синюю'' сетку для $v$),
\item \cvar{cfd::RegularGrid2D::yface_centered_grid()} -- построить сетку по центрам $y$-граней (``красную'' сетку для $u$),
\end{itemize}

и функции перевода индексов
\begin{itemize}
\item \cvar{cfd::RegularGrid2D::cell_centered_grid_index_ip_jp} -- посчитать линейный индекс ``чёрной'' сетки \eqref{eq:ns2d_kipjp},
\item \cvar{cfd::RegularGrid2D::xface_grid_index_ip_j} -- посчитать линейный индекс ``синей'' сетки \eqref{eq:ns2d_kipj},
\item \cvar{cfd::RegularGrid2D::yface_grid_index_i_jp} -- посчитать линейный индекс ``красной'' сетки \eqref{eq:ns2d_kijp}.
\end{itemize}

\subsubsection{Функция верхнего уровня}
\clisting{open}{"test/cavity_fdm_test.cpp"}
\clisting{line}{"[cavity-fdm-simple]"}

Сначала устанавливаются параметры задачи:
число Рейнолдса,
\clisting{line}{"Re"}
параметры алгоритма SIMPLE,
\clisting{lines-range}{"alpha_u", "alpha_p"}
разбиение сетки, 
\clisting{line}{"n_cells"}
максимальное количество итераций 
\clisting{line}{"max_it"}
и значение невязки, при котором итерации прекращаются
\clisting{line}{"double eps"}

Затем происходит инициализация решателя, который
определён в классе \cvar{CavitySimpleWorker}
\clisting{line}{"CavitySimpleWorker"}
и параметров сохранения. Здесь
первым параметром является флаг сохранения
точных сеточных значений, который установлен в \cvar{false},
а также имя файла с итоговым результатом.
Таким образом сохраняться будет только решение,
интерполированное на основную сетку.
Для целей отладки программы (для просмотра действительных, не интерполированных полей решения)
следует первый флаг установить в \cvar{true}. Тогда помимо \ename{cavity2.vtk.series}, будут
создаваться также файлы \ename{cavity2-u}, \ename{cavity2-v}, \ename{cavity2-p}.
\clisting{until}{"_saver"}

Потом происходит установка начальных значений искомых сеточных векторов: $u=v=p=0$
\clisting{lines-range}{"u_init", "set_uvp"}

и начинается итерационный процесс.
\clisting{line}{"for"}

Внутри цикла
выполняется шаг итерационного процесса, который
возвращает значение итоговой невязки в переменную \cvar{nrm}.
\clisting{line}{"step"}

На печать выводится индекс итерации, значение невязки и значение давления в правом верхнем узле (для контроля сходимости)
\clisting{line}{"cout"}

Сохраняется состояние решателся на пройденную итерацию
\clisting{line}{"save_current"}

и производится проверка на сходимость
\clisting{block}{"if (nrm < eps)"}

В конце производится проверка: при установленных параметрых решение
должно сойтись за 9 итераций:
\clisting{line}{"CHECK"}

\subsubsection{Поля класса решателя}
\clisting{to-start}{}
Класс \cvar{CavitySimpleWorker} хранит в себе набор полей,
характеризующих состояние итерационного процесса.
Некоторые из этих полей (параметры решателя) постоянны (\cvar{const}) и
определяются непосредственно перед вызовом конструктора в инициализаторе. Другие
меняются с продвижением по итерациям.

Среди постоянных полей заданы 4 сетки: основная \cvar{_grid},
``чёрная'' сетка \cvar{_cc_grid} (cell-centered) для давления,
``красная'' сетка \cvar{_yf_grid} (y-face) для $u$,
``синяя'' сетка \cvar{_xf_grid} (x-face) для $v$ (\figref{fig:staggered_grid}).
\clisting{pass}{"private"}
\clisting{until}{"yf_grid_"}
Далее заданы скалярные параметры: число Рейнольдса, шаги сетки и параметры алгоритма SIMPLE
\clisting{until}{"alpha_p_"}

Далее следуют сеточные вектора, характеризующие текущее состояние решателя:
найденные на последней итерации давление и скорости.
\clisting{until}{"v_;"}

Также определяется данные для
сборки систем уравнений: внедиагональные и диагональные коэффициенты диффузии для \cref{eq:ns2d_au,eq:ns2d_ava}
и значения $d^u=d^u$, требуемые для сборки \eqref{eq:ns2d_pprime_slae}.
Поскольку используется постоянные шаги по времени эти коэффициенты являются скалярами.
Ниже задан инициализированный решатель системы уравнений для $p'$.
\clisting{until}{"p_prime_solver_"}

Хранятся левая и правая части систем уравнений \eqref{eq:ns2d_ustar_slae}, \eqref{eq:ns2d_vstar_slae}
для определения пробных значений скорости и расчета невязки.
\clisting{until}{"rhs_v_;"}

Указатели на классы, помогающие сохранять найденные вектора в vtk - формат.
Эти классы инициализируются только в случае, если пользователь указал на 
необходимость сохранения.
\clisting{until}{"writer_all_;"}

\subsubsection{Инициализация решателя}
\clisting{to-start}{}

В секции инициализации конструктора
созаются сетки в единичном квадрате и переписываются параметры решения.
Далее в теле конструктора вычисляются значения
$d^u=d^v$ по формулам \cref{eq:ns2d_du_fdm,eq:ns2d_dv_fdm}
и собирается решатель для $p'$. Как было указано ранее,
матрица системы $A^p$ не меняется
с продвижением по итерациям, поэтому этот решатель можно собрать один раз
до начала счёта.

\clisting{block}{"CavitySimpleWorker::CavitySimpleWorker"}

Начальные значения устанавливаются через вызов функции \cvar{set_uvp}.
Эти начальные значения будут использоваться в качестве значений
с предыдущего итерационного слоя на первой итерации.

В функции происходит переписывание переданных векторов
в приватные поля класса.
\clisting{lines-range}{"set_uvp", "p_"}

После этого данных в классе-решателе достаточно,
для сборки матриц $A^u, A^v$ и правых частей
$b^u, b^v$ для системы уравнений \eqref{eq:ns2d_ustar_slae}, \eqref{eq:ns2d_vstar_slae}.
\clisting{until}{"v_slae()"}

Если посмотреть на выражение для невязки \eqref{eq:ns2d_residual} убрав в нём крышки над переменными, то можно
убедится, что оно аппроксимируется в виде
\begin{equation*}
    r_u = A^u u - b^u.
\end{equation*}
Поэтому после сборки систем уравнений движения, можно вычислить невязку, характеризующую
отклонение установленного в этой процедуре решения от желаемого:
\clisting{until-close}{}

\subsubsection{Шаг итерации SIMPLE}
\clisting{to-start}{}
Осуществляется в процедуре
\clisting{block}{"double CavitySimpleWorker::step()"}
и представляет собой буквальное пошаговое следование алгоритму SIMPLE (\ref{sec:simple-algo}).
В конце опять вызывается функция \cvar{set_uvp} для сборки матриц для следующей итерации
и подсчёта невязки на текущей итерации.

\subsubsection{Сборка системы уравнений для поправки давления}
\clisting{to-start}{}

Сборка системы уравнений \eqref{eq:ns2d_pprime_slae}
осуществляется в процедуре
\clisting{line}{"void CavitySimpleWorker::assemble_p_prime_solver()"}
Сборка происходит с использованием матрицы формата \cvar{cfd::LodMatrix},
удобного для непоследовательной записи.
\clisting{until}{"LodMatrix"}
Заполнение происходит в цикле по раздвоенным индексам $ij$
``чёрной'' сетки для давления:
\clisting{until}{"size_t i"}
Внутри цикла устанавливаются флаги, характеризующие граничный статус текущего узла
\clisting{until}{"is_top"}
Вычисляется значение сквозного индекса по формуле \eqref{eq:ns2d_kipjp}
\clisting{until}{"ind0"}
и значения коэффициентов в формулах \eqref{eq:ns2d_ap}. Поскольку
сетка равномерная, эти значения не меняются для разных узлов
\clisting{until}{"coef_y"}
Далее формулы \eqref{eq:ns2d_ap}
применяются для заполнения матриц
с учётом аппроксимированного граничного условия \eqref{eq:ns2d_bc3}.
Так, запись
\clisting{until-close}{}
для всех неправых узлов с линейным индексом \cvar{ind0} вычисляет индекс 
узла, расположенного правее него с линейным индексом \cvar{ind1},
добавляет слагаемое в диагональный (первое из уравнений \eqref{eq:ns2d_ap}) и
вычитает из недиагонального (четвёртое из уравнений \eqref{eq:ns2d_ap}) элемента
строки \cvar{ind0}.
Для правых узлов работает граничное условие \eqref{eq:ns2d_ap} и выполнять эту процедуру
не нужно.

После заполнения в матрицу вводится граничное условие \eqref{eq:ns2d_bc4}
\clisting{line}{"set_unit_row"}

И матрица передаётся в решатель СЛАУ предварительно сконверованная в формат \cvar{cfd::CsrMatrix}
\clisting{until}{"set_matrix"}

Правая часть собирается заново на каждой итерации по формуле \eqref{eq:ns2d_bp}.
Её реализация представлена в функции
\clisting{line}{"CavitySimpleWorker::compute_p_prime"}
Сначала собирается правая часть системы \eqref{eq:ns2d_pprime_slae} по формуле \eqref{eq:ns2d_bp}:
\clisting{block}{"for (size_t i"}
потом осуществляется установка граничного условия \eqref{eq:ns2d_bc4}
\clisting{line}{"rhs[0]"}
и вызывается решатель СЛАУ
\clisting{until-close}{}

\subsubsection{Сборка системы уравнений для пробной скорости}
\clisting{to-start}{}

Сборка системы \eqref{eq:ns2d_ustar_slae} (как правой, так и левой частей) реализована
в функции
\clisting{line}{"CavitySimpleWorker::assemble_u_slae"}

Основной цикл идёт по негрничным узлам ``красной'' сетки,
в котором реализуются формулы \eqref{eq:ns2d_au}
\clisting{pass}{"internal"}
\clisting{block}{"for (size_t", "rhs"}

Как было отмечено в пункте \ref{sec:simple-bc},
граничные условия первого рода в этом уравнении
учитываются двумя разными способами:
узлы расположенные непосредственно на границе (нижней и верхней)
учитываются по схеме \eqref{eq:ns2d_bc1}, которая реализована в цикле
\clisting{to-start}{}
\clisting{block}{"for (size_t j = 0; j < grid_.ny(); ++j)"}

А фиктивные узлы, возникающие при обработке
узлов расположенных в полушаге от границ (левой и правой),
обрабатываются по схеме \eqref{eq:ns2d_bc2}.
Эта схема реализована в виде
препроцессинга алгоритма добавления элемента в матрицу в лямбда-функции
\clisting{to-start}{}
\clisting{pass}{"assemble_u_slae"}
\clisting{block}{"add_to_mat"}

Эта лямбда вызывается везде, где нужно добавить в строку \cvar{row_index}
и колонку, соответствующую узлу \cvar{ij_col}, значение \cvar{value}.
Она перехватывает ситуации с ``фиктивным'' узлом ($j=-1, j=n_y$)
и применяет алгоритм \eqref{eq:ns2d_bc2}.
