\subsection{Лекция 3 (27.09.25) Поправка на скошенные сетки и периодические г.у.}
Теория: \secref{sec:nonortho_fvm}

В тесте \cvar{poisson2-fvm} из файла \ename{poisson_fvm_test.cpp}
реализовано решение двумерного уравнения Пуассона с граничными условиями первого рода.
Используется явный итерационный алгоритм поправки на скошенность.
Определение вектора $\vec c'$ осуществляется методом поворота.
Отталкиваясь от этой реализации необходимо:
\begin{enumerate}
\item Задаться тестовой функцией, периодичной в направлении $x$ с единичным периодом. Пересчитать для неё вектор правой части и повторить тест.
\item Проиллюстрировать решение с помощью изолиний \secref{sec:paraview-isolines}. Сравнить решения на грубой сетке без поправки и с поправкой.
\item Построить серию сгущающихся сеток с помощью алгоритма \ename{tetragrid.py}. Показать второй порядок аппроксимации схемы с поправкой
\item Реализовать вычисление вектора $\vec c'$ с помощью методов прямой и обратной проекции из \secref{sec:cprime_a}.
      Сравнить скорость сходимости этих методов, нарисовав зависимость нормы от номера итерации для трёх методов
\item Реализовать периодические условия по граням $x=0,1$. Сравнить графики сеточной сходимости решения для этой задачи с задачей с условиями первого рода
\end{enumerate}

Работа с расширенным набором точек коллокации в тестовой программе
осуществляется в объекте \cvar{ecol_} класса \cvar{FvmExtendedCollocations}.
Из него берутся:
\begin{itemize}
\item \cvar{points} -- координаты точек коллокации,
\item \cvar{size()} -- количество точек коллокации,
\item \cvar{tab_face_colloc()} -- таблица связности \quo{грань -- точка коллокации}
\item и т.д. Полный список методов смотри в файле \ename{fvm/fvm_extended_collocations.hpp}.
\end{itemize}

Нумерация точек коллокаций устроена так, что первые $N$ (по количеству ячеек) индексов соответствуют внутренним точкам,
оставшиеся $N^\Gamma$ -- граничные точки коллокации.

Подсчёт градиентов в центрах граней осущесвляется методом наименьших
квадратов \secref{sec:fvm_mse_grad} и реализован в объекте \cvar{grad_computer_} класса \cvar{IFvmFaceGradient}.

В тестовой задаче использовался алгоритм, в котором $|\vec c'| = 1$.
Поэтому эта поправка не вносилась в левую часть. То есть использовался алгоритм
\cref{eq:fvm_assem_internal} вместо \cref{eq:fvm_assem_extended_explicit_corr_lhs}.
В случае использования алгоритма поворота эти процедуры идентичны.
Следует обратить на это внимание при программировании алгоритмов с проекциями, где $|\vec c'| \neq 1$.

В представленном коде не производится разделения на шаг инициализации и шаг итерации, как описано в алгоритме
явного учёта поправки в \secref{sec:ortho_correction_assembly}.
Вместо это и правая и левая часть целиком пересобираются на каждой итерации.
За счёт реализации такого разделения код может быть оптимизирован.

\paragraph{Рекомендации к программированию периодических условий}
По аналогии с классом \cvar{DirichletFace} следует
создать класс \cvar{PeriodicFacePair} куда следует
положить индексы соответствующих друг другу периодических граней
и соотвествующие им точки коллокации.
Сборку массива периодических пар следует проводить в процедуре
\cvar{initialize}, которую, вероятно, следует сделать виртуальной.
Отличить граничную грань первого рода от периодической граничной грани
можно по координате её центра \cvar{grid_->face_center(iface)}.

Для отладки процедуры сборки можно
пользоваться процедурами печати полной матрицы (если матрица совсем маленькая)
-- \cvar{dbg::print(mat)} и 
печати  одной выбранной строки \cvar{dbg::print(irow, mat)}.
Эти процедуры определены в файле \ename{dbg/printer.hpp}.

Если не получается решить сразу решить задачу для неструктурированной сетки,
имеет смысл попробовать решить задачу на регулярной сетке. Чтобы отсечь возможные 
ошибки, связанные с учётом неортогональности.
