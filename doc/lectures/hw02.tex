\subsection{Лекция 2 (20.09.25) МКО для решения уравнения Пуассона}
\label{sec:hw_fvm2d}
Теория: \secref{sec:FVM}

В тесте \cvar{poisson1-fvm} из файла \ename{poisson_fvm_test.cpp}
реализовано решение одномерного уравнения Пуассона с граничными условиями первого рода.
Проводится расчёт на сгущающихся сетках с количеством ячеек от 10 до 1000
и расчитываются среднеквадратичные нормы отклонения полученного численного решения от точного.
Решения сохраняются в vtk-файлы \ename{poisson1_fvm_n={}.vtk}.
Отталкиваясь от этой реализации необходимо:
\begin{enumerate}
\item написать аналогичный тест для двумерного уравнения,
\item провести серию расчётов на сгущающихся сетках разных типов (структурированных, pebi и скошенных),
\item визуализировать в Paraview полученное на этих сетках решение,
\item построить графики сеточной сходимости решения и определить порядок аппроксимации метода,
\item в тестовой программе производится сборка в цикле по ячейкам (\secref{sec:poisson_fvm_cellbased}).
      Следует переписать процедуру сборки в циклах по граням (\secref{sec:poisson_fvm_facebased}) и убедиться
      в идентичности результатов.
\end{enumerate}

\subsubsection{Работа с сетками}
Все сетки в программе наследуются от абстрактного класса \cvar{IGrid}.
Необходимые для работы с сетками таблицы узлов, свойств и связности доступны
как виртуальные методы этого класса и объявлены в заголовочном файле \cvar{grid/i_grid.hpp}. Например
\begin{itemize}
\item \cvar{Point IGrid::point(size_t ipoint)} -- получить координату $i$-ой точки,
\item \cvar{Point IGrid::face_area(size_t iface)} -- площадь $i$-ой грани,
\item \cvar{Point IGrid::tab_cell_face(size_t icell)} -- получить список индексов граней для $i$-ой ячейки.
\end{itemize}
Грани (внутренние и граничные) пронумерованы сквозным образом.
Координаты точек всегда трёхмерные. Для двумерных и одномерных задач ``лишние'' координаты приравниваются нулю.

С помощью метода \cvar{IGrid::save_vtk} сетка может быть экспортирована в vtk формат и просмотрена в Paraview.
В \secref{sec:paraview} приведены некоторые приёмы визуализации численного решения.

Для построения двумерных сеток необходимо использовать класс \cvar{Grid2}:
\begin{cppcode}
// сетка 10х10 в единичном квадрате
auto grid = std::make_shared<RegularGrid2D>(0, 0, 1, 1, 10, 10);
\end{cppcode}

Неструктурированные сетки должны быть прочитаны из файла:

\begin{cppcode}
// Читаем сетку из файла /app/test_data/pebigrid.vtk
std::string fn = test_directory_file("pebigrid.vtk");
UnstructuredGrid2D grid = UnstructuredGrid2D::vtk_read(fn);
\end{cppcode}

Строить неструктурированные сетки следует с помощью утилиты \ename{hybmesh}.
В папке \ename{test_data} корневой директории репозитория лежат скрипты построения сеток:
\begin{itemize}
\item \ename{pebigrid.py} -- pebi--сетка,
\item \ename{tetragrid.py} -- сетка, состоящая из произвольных (скошенных) трех- и четырехугольников.
\end{itemize}
Инструкции по запуску этих скриптов смотри п. \ref{sec:hybmesh}.
Эти скрипты строят равномерную неструктурированную сетку
в единичном квадрате
и записывают её в файл vtk, который впоследствии можно загрузить
в расчётную программу.
В каждом из скриптов есть параметр \cvar{N}, означающий
примерное количество ячеек в итоговой сетке.
Меняя его значение можно строить сетки разного разрешения.

Для загрузки построенной сетки в решатель необходимо файл
с сеткой поместить в каталог \ename{test_data}
и далее загрузить её в класс \cvar{UnstructuredGrid2D}.

\subsubsection{Тестовая задача}
Для тестирования двумерной задачи следует использовать двумерное точное решение.
Например,
\begin{cppcode}
double exact_solution(Point p) const override{
    double x = p.x();
    double y = p.y();
    return cos(10*x*x)*sin(10*y) + sin(10*x*x)*cos(10*x);
}
\end{cppcode}
Для вычисления правой части (функции \cvar{exact_rhs})
нужно подставить точное решение в исходное уравнение \cref{eq:poissonnd}.

\subsubsection{График сходимости}
График сеточной сходимости следует строить по аналогии с графиком на \figref{fig:poisson_convergence}.
в логарифмических осях, где по оси абсцисс отлежено разбиение, а по оси ординат -- норма.
Где разбиение -- это число, обратное к характерному линейному размеру ячейки. Его размерность -- $L^{-1}$.
Для получения корректного порядка аппроксимации в двух- и трёхмерных задачах следует внимательно отнестись к вычислению этого параметра.
Для двумерной (трёхмерной) ячейки характерный размер можно определить как корень квадратный (кубический) от объёма ячейки.

\subsubsection{Рекомендации к программированию}
Свои программы следует оформлять в виде отдельных тестов (вместо того, чтобы модифицировать существующие).
Желательно, после того как программа заработает, сразу оставить несколько базовых \cvar{CHECK} проверок и
сделать локальный коммит, чтобы впоследствии легко распознавать и исправлять внесённые в дальнейшей работе ошибки.

При написании новых тестов следует переиспользовать уже написанный код, избегая копирования.
Для этого необходимо оформлять повторяющийся код в виде отдельных процедур и пользоваться механизмами наследования классов.
