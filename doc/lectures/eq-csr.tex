\subsection{Форматы хранения разреженных матриц}
\label{sec:sparse-matrix}
\subsubsection{CSR-формат}
\label{sec:csr}
При реализации решателей систем сеточных уравнений важно учитывать
разреженный характер используемых в левой части. То есть избегать
хранения и ненужных операций с нулевыми элементами матрицы.

Хотя рассмотренные ранее алогритмы конечноразностных аппроксимаций на структурированных сетках
давали трёх- (для одномерных задач) или пятидиагональную (для двумерных) сеточную матрицу,
здесь будем рассматривать общие форматы хранения, не привязанные к конкретному шаблону.

Любой общий
формат хранения должен хранить
информацию о шаблоне матрице (адресах ненулевых элементов)
и значениях матричных коэффициентов в этом шаблоне.

В CSR (Compressed sparse rows) формате
все ненулевые элементы хранятся в линейном массиве \ename{vals}.
А шаблон матрицы -- в двух массивах
\begin{itemize}
	\item массиве колонок \ename{cols} -- значений колонок для соответствующих ему значений из массива \ename{vals},
	\item массиве адресов \ename{addr} -- индексах массива \ename{vals}, с которых начинается описание соответствующей строки.
\end{itemize}
В конце массива \ename{addr} добавляется общая длина массива \ename{vals}.

Таким образом, длины массивов \ename{vals}, \ename{cols} равны количеству ненулевых элементов матрицы,
а длина массива \ename{addr} равна количеству строк в матрице плюс один.

Для облегчения процедур поиска описание каждой строки должно идти последовательно
с увеличением индекса колонки.

Для примера рассмотрим следующую матрицу
\begin{equation}
\label{eq:example-sparse-matrix}
\left(
\begin{array}{cccc}
2.0 & 0 & 0 & 1.0 \\
0 & 3.0 & 5.0 & 4.0 \\
0 & 0 & 6.0 & 0 \\
0 & 7.0 & 0 & 8.0 \\
\end{array}
\right)
\end{equation}

Массивы, описывающие матрицу в формате CSR примут вид

\begin{equation*}
\begin{array}{r|l|l|l|l|l}
      & row=0     & row=1          & row=2& row=3&\\
\hline
vals= & 2.0, 1.0, & 3.0, 5.0, 4.0, & 6.0, & 7.0, 8.0 &\\
\hline
cols= & 0,\phantom{.0} 3,\phantom{.0}      & 1,\phantom{.0}2,\phantom{.0}3,\phantom{.0}          & 2,\phantom{.0}   & 1,\phantom{.0} 3     &\\
\hline
addr= & 0,        & 2,             & 5,   & 6,       & 8 \\
\hline
\end{array}
\end{equation*}

Рассмотрим реализацию базовых алгоритмов для матриц, заданных в этом формате.

Пусть матрица задана следующими массивами:
\begin{minted}[linenos=false]{c++}
std::vector<double> vals; // массив значений
std::vector<size_t> cols; // массив столбцов
std::vector<size_t> addr; // массив адресов
\end{minted}

Число строк в матрице:
\begin{minted}[linenos=false]{c++}
size_t nrows = addr.size()-1;
\end{minted}

Число элементов в шаблоне (ненулевых элементов)
\begin{minted}[linenos=false]{c++}
size_t n_nonzeros = vals.size();
\end{minted}

Число ненулевых элементов в заданной строке `irow`
\begin{minted}[linenos=false]{c++}
size_t n_nonzeros_in_row = addr[irow+1] - addr[irow];
\end{minted}

Умножение матрицы на вектор `v` (длина этого вектора должна быть равна числу строк в матрице).
Здесь реализуется суммирование вида
\begin{equation*}
    r_i = \sum_{j=0}^{N-1} A_{ij} v_j,
\end{equation*}
при этом избегаются лишние операции с нулями
\begin{minted}[linenos=false]{c++}
// число строк в матрице и длина вектора v
size_t nrows = addr.size() - 1;
// массив ответов. Инициализируем нулями
std::vector<double> r(nrows, 0);
// цикл по строкам
for (size_t irow=0; irow < nrows; ++irow){
	// цикл по ненулевым элементам строки irow
	for (size_t a = addr[irow]; a < addr[irow+1]; ++a){
		// получаем индекс колонки
		size_t icol = cols[a];
		// значение матрицы на позиции [irow, icol]
		double val = vals[a];
		// добавляем к ответу
		r[irow] += val * v[icol];
	}
}
\end{minted}


Поиск значения элемента матрицы по адресу \cvar{(irow, icol)} с учётом локально сортированного вектора \cvar{cols}
\begin{minted}[linenos=false]{c++}
using iter_t = std::vector<size_t>::const_iterator;
// указатели на начало и конец описания строки в массиве cols
iter_t it_start = cols.begin() + addr[irow];
iter_t it_end = cols.begin() + addr[irow+1];
// поиск значения icol в отсортированной последовательности [it_start, it_end)
iter_t fnd = std::lower_bound(it_start, it_end, icol);
if (fnd != it_end && *fnd == icol){
	// если нашли, то определяем индекс найденного элемента в массиве cols
	size_t a = fnd - cols.begin();
	// и возвращаем значение из vals по этому индексу
	return vals[a];
} else {
	// если не нашли, значит элемент [irow, icol] находится вне шаблона. Возвращаем 0
	return 0;
}
\end{minted}

Формат CSR обеспечивает максимальную компактность хранения
разреженной матрицы и при этом удобен для последовательной итерации по элементам матрицы (операции умножения матрицы на вектор),
но его существенным недостатком является высокая сложность добавления нового элемента в шаблон.

\subsubsection{Массив словарей}
\label{sec:lodmat}
При реализации сеточных методов решения дифференциальных уравнений работу с матрицами
можно разбить на два этапа: сборка матриц и их непосредственное использование.
Сборка матрицы в свою очередь может быть разделена на
этап вычисление шаблона матрицы (символьная сборка) и
непосредственное вычисление коэффициентов матрицы (числовая сборка).

На этапе использования матрицы основной операцией
является умножение матрицы на вектор, где наиболее эффективным является CSR-формат.

В случае использования неструктурированных сеток этап символьной сборки
является нетривиальной операцией и сводится к неупорядоченному добавлению
новых элементов в шаблон матрицы. Как было отмечено ранее, 
такая операция в случае использования CSR формата неэффективена.

Поэтому часто для этапов сборки и расчёта используют
разные форматы хранения матриц, первый из которых оптимизирован для операции вставки, а второй -- для операции умножения на вектор.
В качестве формата, оптимизированного для вставки, можно представить формат массива словарей (List of dictionaries), где каждая строка матрицы
описывается словарём, ключём которого является индекс колонки, а значением -- величина соответствующего матричного коэффициента.

С использованием синтаксиса C++ такой формат может быть описан следующим образом:
\begin{cppcode}
std::vector<std::map<size_t, double>> data;
\end{cppcode}

Марица вида \eqref{eq:example-sparse-matrix} в таком формате примет вид
\begin{cppcode}
data = {
	{0: 2.0, 3: 1.0},
	{1: 3.0, 2: 5.0, 3: 4.0},
	{2: 6.0},
	{1: 7.0, 3: 8.0}
};
\end{cppcode}

Добавление нового матричного коэффициента сведётся к вставке элемента в словарь:
\begin{cppcode}
data[i][j] = value;
\end{cppcode}

А основной операцией для такого формата будет служить
конверсия в CSR:
\begin{cppcode}
std::vector<size_t> addr{0};
std::vector<size_t> cols;
std::vector<double> vals;
for (size_t irow=0; irow < data.size(); ++irow){
	for (auto it: data[irow]){
		cols.push_back(it.first);
		vals.push_back(it.second);
	}
	addr.push_back(addr.back() + data[irow].size());
}
\end{cppcode}
Поскольку данные в контейнере типа \cvar{std::map} итерируются
в отсортированном по ключам порядке, то полученный
в результе массив \cvar{cols} также является локально отсортированным.
