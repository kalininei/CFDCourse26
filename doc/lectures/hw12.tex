\subsection{Лекция 12 (29.11.25) Стабилизация методом SUPG}
\label{sec:fem_supg}
В тесте \cvar{[transport1_supg]} из файла \ename{transport_supg_test.cpp}
реализовано решение одномерного уравнения переноса
c использованием SUPG схемы на основе временн`{о}й дискретизации Кранка-Николсон.
В качестве параметра стабилизации использовано значение $\epsilon = |\vec U| h / 2$.
\begin{enumerate}
\item
Переписать параметр стабилизации в форме $\epsilon = k |\vec U| h / 2$.
Так, что $k=0$ соответствует нестабилизированному методу.
Исследовать поведение решения в зависимости от $k\in[0, 2]$.
Для исследования выбрать $h=0.02$ и $\dt$, соответсвующие числа Куранта $C = 0.2, 0.5, 1.0$.
В качестве метрики использовать норму отклонение $L_2$, а также $L_{osc} = -\min(0, u_i)$, показывающую величину осцилляций.
Для каждого выбранного $\dt$ нарисовать $L_2(k)$, $L_{osc}(k)$.
\item
Решить аналогичную одномерную задачу, где вместо условий Дирихле использовать периодические граничные условия
(в этом случае волна должна покидать расчётную область справа и тут же появляться слева).
Нарисовать графики $L_2(t), L_{osc}(t)$ для некоторых выбранных значений $C$ и $k$.
\item
Рассмотреть двумерную задачу первого рода с полем скорости $\vec U = 0.5\left(\sqrt{2}, \sqrt{2}\right)$.
и начальным условием
\begin{equation*}
u(x, y, 0) = \exp\left(-\frac{r^2}{\sigma^2}\right), \quad \sigma = 0.1, \quad r = \sqrt{(x - 0.2)^2 + (y - 0.2)^2}.
\end{equation*}
Использовать треугольные линейные элементы. Расчёт вести до $t = 0.5$.
Анимировать решение.
Нарисовать графики $L_2(t), L_{osc}(t)$ для выбранных значений $C$ и $k$ 
и сравнить с аналогичными графиками одномерной задачи из п.2 для сходного пространственного шага $h$.
\item
Решить задачу из п.3, вычисляя шаг $h$ в стабилизирующем слагаемом как проекцию элемента на вектор скорости.
Сравнить метрики $L_2$, $L_{osc}$ с метриками из п.3.
\item
Решить задачу из п.3, используя полную (не направленную вдоль вектора скорости) диффузию.
Сравнить картину решения с картиной из п.3.
\end{enumerate}

\paragraph{Рекомендации к программированию}
\begin{itemize}
\item
Для п.1 ввести параметр $k$ как аргумент конструктора класса \cvar{ATestTransportWoker} 
и использовать его в методе \cvar{stab}, который расчитывает стабилизирующую часть
пробной функции для подинтегральных выражений.
\item
Для учёта периодических условий на матричном в п.2 уровне следует 
модифицировать методы \cvar{apply_dirichlet_bc},
используя функции \cvar{algebraic_bc_periodic} для матричного и векторного аргументов.
Эти функции реализуют алгоритм \secref{sec:periodic_fvm}.
В качестве \cvar{connections} следует передавать словарь периодических соответствий узлов. В одномерном случае -- связь первого и последнего расчётных узлов:
\cvar{ {{0, grid_.n_points()-1}} }.
Особое внимание уделить начальному условию. В отличие от случая условий первого рода, здесь следует
учесть, что в начальный момент половина волны находится в начале расчётной области, а половина -- в конце.
\item
Для решения двумерной задачи из п.3 следует создать классы \cvar{Solution2D} и
\cvar{FemLinearTriangle} по аналогии с \secref{sec:fem_tvd}.
\item
Для вычисления проекции элемента на вектор скорости для п.4
нужно внутри метода \cvar{stab} получить проекции
всех точек элемента на вектор скорости.
\begin{cppcode}
for (size_t ipoint: grid_->tab_cell_point(ielem)){
    Point p = grid_->point(ipoint);
    double proj = dot_product(p, velocity) / abs_velocity;
}
\end{cppcode}
Шаг $h$ будет равен разности максимальной и минимальной проективной координат.
\item
Чтобы решить задачу из п.5 нужно использовать обычную, нестабилизированную матрицу масс, 
а при вычислении матрицы переноса нужно добавить к ней диффузию. Для этого
использовать следующую подинтегральную функцию
\begin{cppcode}
auto fun = [&el](Point p) -> std::vector<double> {
    const size_t n = el.basis->size();
    std::vector<double> ret(n * n, 0.0);
    auto val = FemElementValue(&el, p);
    // velocity
    const std::vector<Vector> element_velocity = fem_.local_vector(ielem, velocity_);
    Vector vel = val.interpolate(element_velocity);
    double abs_velocity = vector_abs(vel);
    // compute eps
    double h = grid_->cell_size(ielem);
    double eps = abs_velocity * h / 2;

    for (size_t ibas = 0; ibas < n; ++ibas) {
        for (size_t jbas = 0; jbas < n; ++jbas) {
            const size_t k1 = ibas * n + jbas;
            Vector g1 = val.grad_phi(ibas);
            Vector g2 = val.grad_phi(jbas);

            // -vel * nabla(phi_j) * phi_i         - transport
            // -eps * nabla(phi_j) * nabla(phi_i)  - stabilized stiffness
            ret[k1] = (- dot_product(vel, g2) * val.phi(ibas) 
                       - eps * dot_product(g1, g2)) * val.modj();
        }
    }
    return ret;
};
\end{cppcode}
\end{itemize}
