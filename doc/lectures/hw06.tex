\subsection{Лекция 6 (18.10.25) Метод линейных конечных элементов}
\label{sec:fem_programming_problem}
В тесте \cvar{poisson1-fem-linsegm} из файла \ename{poisson_fem_test.cpp}
реализовано решение одномерного уравнения Пуассона. Разбор этой программы смотри в \secref{sec:fem_programming}.
На основе этого теста необходимо
\begin{enumerate}
\item
Показать второй порядок аппроксимации решения одномерного уравнения Пуассона на линейных конечных элементах;
\item
Вместо используемых точных формул вычисления элементых матриц использовать квадратурные формулы.
Нарисовать графики сеточной сходимости при использовании квадратурных формул, точных для полиномов 1-ой и 2-ой степеней.
\item
Решить двумерное уравнение Пуассона с граничными условиями первого рода в квадтратной области на треугольной сетке.
Для построения треугольных сеток различного разрешения использовать скрипт \ename{trigrid.py}.
Показать сеточную сходимость при сипользовании квадтратурных формул, точных для полиномов 1-ой, 2-ой и 3-ей степеней.
\item
Реализовать квадтратурноую формулу, с узлами, расположенными в узлах модельного треугольного элемента: $\xi_0(0, 0)$, $\xi_1(1, 0)$, $\xi_2(0, 1)$ и равными весами $w_i = 1/6$.
Построить график сеточной сходимости и сравнить с результатом из предыдущего пункта.
\end{enumerate}

\paragraph{Рекомендации к программированию}
Программировать вычисления локального вектора нагрузок,
матрицы масс и матрицы жёсткости (пункт 2) с помощью общих квадтратурных формул лучше всего путём
определения функций \cvar{element_load_vector}, \cvar{element_mass_matrix} и \cvar{element_stiffness_matrix}
на уровне базового класса \cvar{ITestPoissonFemWorker}.
Тогда переключать программу в режим работы по квадтратурным функциям можно
с помощью вызова родительского метода из частного. Например для вектора нагрузок:
\begin{cppcode}
std::vector<double> TestPoissonLinearSegmentWorker::element_load_vector(size_t ielem) const{
    return ITestPoissonFemWorker::element_load_vector(ielem);
}
\end{cppcode}
Более того, реализация базового метода с помощью универсального алгоритма позволит не делать
частную реализацию при программировании двумерной задачи (пункт 4).

Для самой реализации необходимо
задать набор квадратур для конечного элемента \cvar{FemElement} путём определения поля \cvar{quadrature}
через одну из квадтратур, заданных в \ename{quadrature.hpp}.
Для этого в методе \cvar{build_fem} (где осуществляется сборка элементов) вместо нулевого указателя задать конкретную формулу:
\begin{cppcode}
auto quad = quadrature_segment_gauss2(); // полином 2-го порядка
\end{cppcode}
Далее непосредственно в методе \cvar{element_...}
получить конечный элемент (объект класса \cvar{FemElement}) по его индексу можно через объект сборщика
\begin{cppcode}
auto elem = fem_.element(ielem);
\end{cppcode}
В свою очередь из этого объекта можно получить как квадратурные коэффициенты:
\begin{cppcode}
std::shared_ptr<const Quadrature> quad = elem->quadrature;  // коэффициенты квадратурной формулы
\end{cppcode}
так и все необходимый функционал для вычисления подинтегральных выражений функций \cref{eq:fem_load_vector_xi,eq:fem_mass_matrix_xi,eq:fem_stiff_matrix_xi}:
\begin{cppcode}
auto basis = elem->basis;   // shape-функции с параметрическом пространстве
auto geom = elem->geometry; // геом. свойства включая матрицу Якоби
\end{cppcode}
Реализацию интегрирования проводить по примеру из
\secref{sec:fem_quad_prog}.

Для реализации двумерного решения (пункт 3)
следует по аналогии с одномерным написать класс
\cvar{ITestPoisson2FemWorker},
в котором реализовать двумерные функции точного решения и правой части,
и наследуемый от него рабочий класс 
\cvar{TestPoissonLinearSegmentWorker},
в котором реализовать статическую функцию \cvar{build_fem}.
Треугольные конечные элементы собирать по 
\begin{cppcode}
auto geom = std::make_shared<TriangleLinearGeometry>(p0, p1, p2);
auto basis = std::make_shared<TriangleLinearBasis>();
auto quad = quadrature_triangle_gauss2(); // 2-nd order polynom quadrature
\end{cppcode}
\label{sec:fem_quad_prog}

Треугольную сетку следует положить в папку \ename{test_grid}. После чего она может быть прочитаны из файла:
\begin{cppcode}
// Читаем сетку из файла /app/test_data/trigrid.vtk
std::string fn = test_directory_file("trigrid.vtk");
UnstructuredGrid2D grid = UnstructuredGrid2D::vtk_read(fn);
\end{cppcode}


Для написания собственной квадтратурной формулы (пункт 4) необходимо создать свой объект класса \cvar{Quadrature},
передав в конструктор необходимые узлы и веса.
