\subsection{Лекция 8 (01.11.25) Конечные элементы высокого порядка}
\label{sec:fem_high_order_programming_problem}
Тест \cvar{poisson2-fem-quadtri} из файла \ename{poisson_fem_test.cpp}
реализовано решение двумерного уравнения Пуассона с гранчиными условиями первого рода на квадратичных конечных элементов Лагранжа.

Также в тесте \cvar{poisson2-fem-radial} решена двумерная задача Лапласа со смешанными граничными условиями в кольце:
\begin{align*}
&-\nabla u = 0, \quad r_0 \le r \le r_1, \quad r = \sqrt{x^2 + y^2} \\
&r = r_0: -\dfr{u}{n} = q, \\
&r = r_1: u = 0.
\end{align*}
Известное точное решение этой задачи:
\begin{equation*}
u^{ex} = q  r_0 \ln\left(\frac{r}{r_1}\right).
\end{equation*}
Здесь были использваны линейные конечные элементы, 
но использвалось неполное квадратичное преобразование геометрии
на наборе шейп функций с узлами $$\vec \xi_i = (-1, -1), (1, -1), (1, 1), (-1, 1), (0, -1)$$
при работе с конечными элементами около внутренней границы.

На основе этих тестов необходимо
\begin{enumerate}
\item
Провести расчёт сеточной сходимости и показать порядок аппроксимации используемого метода для первой задачи. Для построения сеток разного разрешения использовать скрипт \ename{trigrid.py}.
\item
Решить ту же задачу с помощью линейных и кубических элементов.
Нарисовать рядом три графика сходимости для элементов первого, второго и третьего порядка.
\item На основе имеющегося теста из второй задачи реализовать полностью линейное
преобразование геометрии. Сравнить два графика сходимости для двух преобразований геометрии. Для построения сеток разного разрешения использовать скрипт \ename{radial.py}.
\item Построить два таких же графика, но с использованием Лагранжевых Q и P элементов второго порядка.
\end{enumerate}

\paragraph{Рекомендации к программированию}
Для понижения порядка используемых сеточных элементов до линейного в п.2 необходимо в функции \cvar{build_fem}
\begin{itemize}
\item правильно указать количество базисов в переменной \cvar{n_bases},
\item указать линейный базис \cvar{TriangleLinearBasis} при создании набора шейп-функций \cvar{basis},
\item при сборке таблицы связности \cvar{tab} убрать упоминание граневых базисов, оставив лишь узловые.
\item так же следует убрать граневые базисы из списка индексов базисных функций, к которым приписаны условия первого рода в
методе \cvar{dirichlet_bases}
\end{itemize}

Чтобы напротив, повысить порядок, использовав кубические элементы \figref{fig:triangle_basis_points}в,
следует ввести следующую нумерацию базисов: сначала удут узловые базисные функции,
зачем граневые (по две на каждую грань) и завершают список элементные bubble-функции.
Тогда нужно
\begin{itemize}
\item изменить \cvar{n_bases},
\item указать кубический базис \cvar{TriangleCubicBasis} при создании набора шейп-функций \cvar{basis},
\item при сборке таблицы связности \cvar{tab} добавить ещё одну граневую базисную функцию и одну bubble-функцию для каждого элемента:
\begin{cppcode}
std::vector<size_t> tab = info.ipoints;   // узловые
for (size_t i=0; i<info.n_points(); ++i){
    size_t iface = info.ifaces[i];
    if (!info.is_face_reverted[i]){  // в правом элементе грань "перевёрнута"
        tab.push_back(grid.n_points() + 2*iface + 0); // две граневые 
        tab.push_back(grid.n_points() + 2*iface + 1);
    } else {
        tab.push_back(grid.n_points() + 2*iface + 1);
        tab.push_back(grid.n_points() + 2*iface + 0);
    }
}
tab.push_back(grid.n_points() + 2*grid.n_faces + icell); // bubble
\end{cppcode}
\item так же следует добавить ещё один граневый базис в списка индексов базисных функций в методе \cvar{dirichlet_bases}
\end{itemize}

Для понижения порядка геометрии до линейной в п.3
достаточно для приграничного Q-элемента указать тот же геометрический класс, что
и для всех остальных:
\begin{cppcode}
el.geometry = std::make_shared<QuadrangleLinearGeometry>(p0, p1, p2, p3);
\end{cppcode}

Чтобы повысить порядок элемента (п.4) до квадратного, следует учесть,
что в настоящей сетке используюутся как четырёхугольные Q-элементы,
так и треугольные P-элементы.
Набор Квадтратичных shape-функций для Q-элементов (см. \figref{fig:quadrangle_basis_points}б)
включает в себя bubble-функцию. Таким образом
общее количество базисов будет равно количеству узлов плюс количество граней плюс количество Q-элементов.
С учётом этого нужно изменить
\begin{itemize}
\item \cvar{n_bases},
\item \cvar{el.basis} -- \cvar{TriangleQuadraticBasis} для P--элементов и \cvar{QuadrangleQuadraticBasis} для Q--элементов
\item таблицу связности \cvar{tab}:
\begin{cppcode}
std::vector<size_t> tab = info.ipoints; // узловые
for (size_t iface: info.ifaces){
    tab.push_back(iface + grid.n_points()); // граневые
}
if (info.n_points() == 4){ // bubble для 4-x узловых
    tab.push_back(grid.n_points() + grid.n_faces() + q_element_index++);
}
\end{cppcode}
где счётчик \cvar{q_element_index} следует инициализировать нулём
до начала цикла по ячейкам \cvar{icell},
\item не забыть добавить граневые базисы в метод \cvar{dirichlet_bases}.
\end{itemize}
