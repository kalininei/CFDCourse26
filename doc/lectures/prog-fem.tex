\subsection{Разбор программной реализации МКЭ}
\label{sec:fem_programming}
\clisting{open}{"test/poisson_fem_test.cpp"}
Численное решение уравнения Пуассона с граничными
условиями первого рода реализовано в файле
\ename{poisson_fem_test.cpp}.
Будем рассматривать решение одномерной задачи с использованием пирамидальных базисов (тест \ename{[poisson1-fem-lintri]}).
В этом тесте определяется аналитическая функция
$$
f(x) = \sin(10 x^2),
$$
и формулируется уравнение Пуассона с граничными условиями первого рода, для которого эта функция является точным решением.
Далее уравнение Пуассона решается численно и полученный численный результат сравнивается
с точным ответом. Норма полученной ошибки печатается в консоль.

В функции верхнего уровня происходит построение одномерной
сетки, создание рабочего объекта, вызов решения с возвращением нормы полученной ошибки
и вывод данныех (сохранение решения в vtk-файл и печать нормы в консоль):
\clisting{pass}{"[poisson1-fem-linsegm]"}
\clisting{lines-range}{"Grid1D", "std::cout"}
Основная работа происходит в классе \cvar{TestPoissonLinearSegmentWorker}.

\subsubsection{Рабочий объект}
В конструкторе класса \cvar{TestPoissonLinearSegmentWorker}
происходит вызов статической функции \ename{build_fem},
в которой осуществляется сборка массива конечных элементов и таблицы 
связности \quo{элемент--индексы базисов, определённых в элементе} (таблица \cvar{glob} из алгоритма \cvar{eq:fem_vector_assemble}).
Эти данные используются для построения конечноэлементного сборщика (\secref{sec:fem_fem_assembler}).

В родительском класса рабочего объекта 
\cvar{ITestPoisson1FemWorker},
сформулированы аналитические функции, служащие
правой частью, точным решением и условиями первого рода уравнения Пуассона.

А в базовом классе \cvar{ITestPoissonFemWorker} реализованы основные процедуры решения уравнения.
\clisting{to-start}{}
\clisting{block}{"double ITestPoissonFemWorker::solve()"}
Для получения решения сначала собирается левая и правая
часть системы линеных уравнений с учётом граничных условий первого рода,
вызывается решатель системы уравнений и вычислитель нормы ошибки.

В функции сборки левой части СЛАУ сначала происходит поэлементная сборка матрицы, соответствующая алгоритму \cref{eq:fem_matrix_assemble}.
\clisting{to-start}{}
\clisting{block}{"CsrMatrix ITestPoissonFemWorker::approximate_lhs() const"}
При этом вычисление элементной матрицы по формуле \cref{eq:fem_stiff_matrix_xi} осуществляется в абстрактном методе \cvar{element_stiffness_matrix}.
В настоящей реализации используется точное вычисление этого интеграла для одномерного линейного элемента.
в переопределённом методе \cvar{TestPoissonLinearSegmentWorker::element_stiffness_matrix}.

Вставка элементной матрицы в глобальную матрицу осуществляется с
помощью специального сборщика \cvar{fem_} класса \cvar{FemAssembler}.

Далее происходит учёт граничных условий первого рода на матричном уровне, с помощью
постановки единицы на диагональ в строку матрицы, соответсвующую граничному узлу (базису).

По аналогичной процедуре работает и сборка правой части \cvar{approximate_rhs}.

\subsubsection{Конечноэлементный сборщик}
\label{sec:fem_fem_assembler}
Конечноэлементный сборщик \cvar{FemAssembler} -- основной класс, хранящий
всю информацию о текущей конечноэлементной аппроксимации: 
массив конечных элементов и их связность.
Эта информация подаётся ему при конструировании (реализация в файле \ename{cfd/fem/fem_assembler.hpp}).
\clisting{open}{"cfd/fem/fem_assembler.hpp"}
\clisting{lines-range}{"FemAssembler(", ");"}
Связность \cvar{tab_elem_basis} имеет формат \quo{элемент-глобальный базис} и
определяет глобальный индекс для каждого локального базисного индекса.
В рассматренных нами узловых конечных элементах базис связан с узлом сетки.
То есть эта таблица -- это связность локальной и глобальной нумерации узлов сетки для каждой ячейки сетки.

Конечноэлементный сборщик создаётся в методе
\cvar{TestPoissonLinearSegmentWorker::build_fem} итогового
рабочего класса (то есть сборщик специфичен для конкретной сетки
и конкретного выбора типов элементов). Далее он пробрасывается в конструктор базового рабочего класса.

\subsubsection{Концепция конечного элемента}
\clisting{open}{"cfd/fem/fem_element.hpp"}
Класс конечного элемента \cvar{FemElement} определён в файле
\ename{fem/fem_element.hpp} как
\clisting{block}{"struct FemElement"}
Главная задача объекта этого класса -- предоставлять всю информацию для вычисления элементных векторов и матриц,
которые впоследствии используются сборщиком
для создания глобальных матриц.
Для расчёта элементных матриц в свою очередь требуется
\begin{itemize}
\item Геометрия элемента, включающая в себя правило отображения элемента из физической в параметрическую область и матрицу Якоби,
\item Набор shape-функций, заданных в модельной геометрии,
\item Непосредственно правило интегрирования в параметрической области (квадратурные формулы)
\end{itemize}
Каждый из этих трёх алгоритмов определён через объекты классов
\begin{itemize}
\item \cvar{IElementGeometry}
\item \cvar{IElementBasis}
\item \cvar{Quadrature}
\end{itemize}
Полное определение конечного элемента заключается в задании конкретных реализаций первых двух интерфейсов и объекта с квадратурой.

\subsubsubsection{Определение линейного одномерного элемента}
\label{sec:linear_segment_assembly}.
Так, в рассматриваемом нами тесте \ename{"[poisson1-fem-linsegm]"}, используются только линейные одномерные элементы.
Используется следующее определение элемента:
\clisting{open}{"test/poisson_fem_test.cpp"}
\clisting{pass}{"TestPoissonLinearSegmentWorker::build"}
\clisting{lines-range}{"geom =", "FemElement"}
Здесь последовательно определяются:
\begin{itemize}
\item
геометрия отрезка \cvar{geom} -- путём задания двух точек в физичекой плоскости \cvar{p0, p1},
\item
линейный одномерный базис \cvar{basis},
\item
правила интегрирования \cvar{integrals} по параметрическому отрезку $x \in [-1, 1]$
не задаются (используется \cvar{nullptr}), поскольку в дальнейшем
интегрирование ведётся по точным формулам.
\end{itemize}

\subsubsubsection{Геометрические свойства элемента}
\clisting{open}{"cfd/fem/fem_element.hpp"}
Интерфейс \cvar{IElementGeometry}, заданный в файле \ename{cfd/fem/fem_element.hpp},
определяет геометрические свойства элемента:
\clisting{block}{"class IElementGeometry"}
Для вычиселния элементных матриц главным геометрическим свойством
элемента является функция для вычисления матрицы Якоби (\cvar{jacobi}).
В простейших реализациях этого интерфейса для сиплексных геометрий
матрица Якоби постоянна для любой точки, то есть функция \cvar{jacobi} возвращает
один и тот же ответ вне зависимости от переданного аргумента.

Кроме того, этот интерфейс предоставляет функции преобразования координат из физического простравнства
в параметрическое и обратно: \cvar{to_parametric}, \cvar{to_physical}. А также задает центральную точку
в параметрическом пространстве \cvar{parametric_center}.

\subsubsubsection{Элементный базис}
Интерфейс для определения локального элементного базиса (набора shape-функций) имеет вид
\clisting{open}{"cfd/fem/fem_element.hpp"}
\clisting{block}{"class IElementBasis"}
Этот интерфейс работает только с параметрическим пространстсвом
и определяет следующие методы:
\begin{itemize}
\item \cvar{size} -- количество базисных функций;
\item \cvar{parametric_reference_points} -- вектор из параметрических коордианат
      точек, приписанных к соответствующим базисам;
\item \cvar{value} -- значение базисных функций в заданной точке;
\item \cvar{grad} -- градиент (в параметрическом пространстве) базисных функций по заданным точкам.
\item \cvar{upper_hessian} -- верхняя часть матрицы Гессе (вторые производные базисных функций в заданной точке)
\end{itemize}

Конкретная реализация например для линейного треугольного элемента \cvar{TriangleLinearBasis}
(в файле \ename{cfd/fem/elem2d/triangle_linear.cpp})
включает в себя линейный Лагранжев базис в двумерном пространстве согласно
\cref{eq:triangle_linear_basis}:
\clisting{open}{"cfd/fem/elem2d/triangle_linear.cpp"}
\clisting{block}{"TriangleLinearBasis::size"}
\clisting{block}{"TriangleLinearBasis::parametric_reference_points"}
\clisting{block}{"TriangleLinearBasis::value"}
\clisting{block}{"TriangleLinearBasis::grad"}

\subsubsubsection{Квадратурные формулы}
\label{sec:fem_quad_prog}
Объект класса \cvar{Quadrature}, определённого в файле \ename{quadrature.hpp},
предоставляет узловые точки и веса для численного вычисления интегралов.
Гауссовы квадратуры доступны в файлах из папки \ename{cfd/numeric_integration}:
\begin{itemize}
\item \ename{segment_quadrature} -- квадтратуры для интегрирования по отрезку $[-1, 1]$,
\item \ename{triangle_quadrature} -- квадтратуры для интегрирования в треугольнике с узлами $(0, 0)$, $(1, 0)$, $(0, 1)$,
\item \ename{square_quadrature} -- квадтратуры для интегрирования в квадтрате $[-1, 1]\times[-1, 1]$.
\end{itemize}
Последняя цифра в названии конкретной квадтратуры -- степень полинома, для которой она точна.
Например, формула \ename{quadrature_segment_gauss4} -- квадратура для 
интегрирования в отрезке $[-1, 1]$, точная для полинома 4-ой степени.

Для того, чтобы проинтегрировать некоторую заданную координатную функцию $f$
с помощью квадратуры, нужно написать цикл вида
\begin{cppcode}
double f(Point xi){
    ...
}
std::shared_ptr<Quadrature> quad = ...;
double integral = 0.0;
for (size_t k=0; k<quad->size(); ++k){
    Point p = quad->point(k);
    double w = quad->weight(k);
   integral += w*f(p);
}
\end{cppcode}
Либо можно воспользоваться методом \cvar{integrate}:
\begin{cppcode}
double integral = quad->integrate(f);
\end{cppcode}

Для упрощения вычисления специфичных для конечноэлементных
интегралов выражений можно
внутри подинтегральной функции  использовать
вспомогательный класс \cvar{FemElementValue},
позволяющий вычислять значение shape-функций (метод \cvar{phi})
и их производные по физическим координатам (методы \cvar{grad_phi}, \cvar{laplace}, \cvar{divirgence}).
