\subsection{Лекция 9 (08.11.25) Решение одномерного уравнения переноса нелинейными TVD-методами}
\label{sec:tvd_fdm}
В тесте \cvar{[transport_fdm_theta]} из файла \ename{transport_fdm_test.cpp}
реализовано решение одномерного уравнения переноса с помощью двухслойных схем.
Тесты, использующие \cvar{TestTransport1WorkerExplicit},
основаны на простой явной схеме типа \cref{eq:tvd_appr_with_f,eq:tvd_fhl,eq:tvd_f}.
Тесты на основе \cvar{TestTransport1WorkerTheta}
решают нелинейное уравнение \cref{eq:tvd_theta_sle} методом простой итерации.
Каждый решатель создает файл \ename{transport1.vtk.series},
в котором с шагом \cvar{save_tau} сохраняется нестационарное решение.
Этот файл можно открыть в Paraview \secref{sec:paraview-1d} и смотреть в динамике.
Так же каждый тест печатает количество использованных ячеек и итоговоую полученную норму.

Необходимо
\begin{enumerate}
\item
Показать динамику изменения решения с параметрами $\tau = 10^{-2}, h = 0.05$ в сравнении:
Exact, Explicit/Upwind, Implicit/Upwind, Crank-Nicolson/Minmod, Crank-Nicolson/Central
на одном графике
\item
Реализовать метода \cvar{TestTransport1WorkerTheta::impl_step}
c использованием метода коррекции поправки (\secref{sec:it_def_corr}),
где в качестве предобуславливателя использовать линейную часть оператора переноса $\mat B = \mat E - \dt \theta \mat L$.
\item
Зафиксировать $\dt = 10^{-4}$ и провести анализ сеточной сходимости в диапазоне разбиений $N=10^1\div10^4$.
Сравнить методы Explicit/Upwind, Implicit/Upwind, Explicit/Minmod, Explicit/Superbee, Crank-Nicolson/Minmod.
Объяснить поведение графиков.
\item Оптимизировать код для максимальной производительности. Привести замеры производительности до и после
на разных настройках.
\end{enumerate}

\paragraph{Рекомендации к программированию}
\begin{itemize}
\item Для реализацию п.2 следует завести новый класс \cvar{TestTransport1WorkerThetaDefectCorr},
наследованный от \cvar{TestTransport1WorkerTheta}, у которого переопределить метод \cvar{impl_step}.
Все необходимые к написанию этого задания матрицы уже вычисляется в родительском классе.
\item В методе коррекции ошибки нужно обращать лишь стационарный предобуславливатель $B$.
Рекомендуется собрать решатель один раз в инициализаторе рабочего класса 
\begin{cppcode}
AmgcMatrixSolver solver_(SOLVER_MAX_ITER, SOLVER_EPS);
solver_.set_matrix(B_);
\end{cppcode}
И далее использовать этот решатель для получения поправки внутри итерационного процесса через метод \cvar{solver_.solve()}.
\item Параметрически расчёты (п.3) следует проводить в релизном режиме и с отключённым выводом в файл
\item Некоторые идеи по оптимизации кода для п.4:
\begin{itemize}
\item Не считать антидиффузию в случае, если настройки её обнуляют (например UPWIND и т.п.)
\item Обратить внимание, что для подсчётна правой части используюется та же антидиффузия, что и для последней итерации на предыдущем временном слое
\item Следует минимизировать использование дорогой и неэффективной операции \cvar{LodMatrix::sum}. А лучше вообще отказатся от класса \cvar{LodMatrix}
\item Возможно для обращения предобуславливателя будет более эффективно исользовать простой метод Зейделя (см. завершающий абзац из \secref{sec:it_def_corr}).
\end{itemize}
\end{itemize}
